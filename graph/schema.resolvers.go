package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.39

import (
	"app/graph/model"
	"context"
	"os"
	"strconv"
	"strings"

	pgx "github.com/jackc/pgx/v5"
)

// AddEnrichedData is the resolver for the addEnrichedData field.
func (r *mutationResolver) AddEnrichedData(ctx context.Context, input model.NewEnrichedData) (string, error) {
	databaseURL := os.Getenv("DATABASE_URL")
	db, err := pgx.Connect(context.Background(), databaseURL)
	if err != nil {
		return "error: can't connect to database", err
	}
	defer db.Close(context.Background())

	query := "INSERT INTO enriched_data (name, surname, patronymic, age, gender, nationality) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id"
	row := db.QueryRow(context.Background(), query, input.Name, input.Surname, input.Patronymic, input.Age, input.Gender, input.Nationality)

	var id int
	if err := row.Scan(&id); err != nil {
		return "error: something went wrong while adding data", err
	}
	return "success: data added", nil
}

// DelEnrichedData is the resolver for the delEnrichedData field.
func (r *mutationResolver) DelEnrichedData(ctx context.Context, id string) (string, error) {
	databaseURL := os.Getenv("DATABASE_URL")
	db, err := pgx.Connect(context.Background(), databaseURL)
	if err != nil {
		return "error: can't connect to database", err
	}
	defer db.Close(context.Background())

	query := "DELETE FROM enriched_data WHERE id = $1"
	res, err := db.Exec(context.Background(), query, id)
	if err != nil {
		return "error: failed to delete row", err
	}
	if res.RowsAffected() == 0 {
		return "error: prodived id not found", nil
	}
	return "success: row deleted", nil
}

// UpdateEnrichedData is the resolver for the updateEnrichedData field.
func (r *mutationResolver) UpdateEnrichedData(ctx context.Context, id string, input model.UpdateEnrichedData) (string, error) {
	databaseURL := os.Getenv("DATABASE_URL")
	db, err := pgx.Connect(context.Background(), databaseURL)
	if err != nil {
		return "error: can't connect to database", err
	}
	defer db.Close(context.Background())

	argsString, args := parseUpdateRequestParams(&input)
	if len(argsString) == 0 {
		return "error: no parameters passed", nil
	}

	args = append(args, id)
	query := "UPDATE enriched_data SET " + strings.Join(argsString, ", ") + " WHERE id = $" + strconv.Itoa(len(args))
	res, err := db.Exec(context.Background(), query, args...)
	if err != nil {
		return "error: failed to update row", err
	}
	if res.RowsAffected() == 0 {
		return "error: provided ID not found", nil
	}
	return "success: updated fields for provided ID", nil
}

// EnrichedData is the resolver for the EnrichedData field.
func (r *queryResolver) EnrichedData(ctx context.Context, page *int, age *string, gender *string, nationality *string) ([]*model.EnrichedData, error) {
	databaseURL := os.Getenv("DATABASE_URL")
	db, err := pgx.Connect(context.Background(), databaseURL)
	if err != nil {
		return nil, err
	}
	defer db.Close(context.Background())

	query, queryArgs := generateGetQuery(*age, *gender, *nationality, *page)
	rows, err := db.Query(context.Background(), query, queryArgs...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	results := []*model.EnrichedData{}
	for rows.Next() {
		var data model.EnrichedData
		err := rows.Scan(&data.ID, &data.Name, &data.Surname, &data.Patronymic, &data.Age, &data.Gender, &data.Nationality)
		if err != nil {
			return nil, err
		}
		results = append(results, &data)
	}
	return results, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
