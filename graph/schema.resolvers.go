package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.39

import (
	"app/graph/model"
	"context"
	"fmt"
	"os"
	"strconv"
	"strings"

	pgx "github.com/jackc/pgx/v5"
	"github.com/joho/godotenv"
)

// AddEnrichedData is the resolver for the addEnrichedData field.
func (r *mutationResolver) AddEnrichedData(ctx context.Context, input model.NewEnrichedData) (*model.EnrichedData, error) {
	panic(fmt.Errorf("not implemented: AddEnrichedData - addEnrichedData"))
}

// DelEnrichedData is the resolver for the delEnrichedData field.
func (r *mutationResolver) DelEnrichedData(ctx context.Context, id string) (*string, error) {
	panic(fmt.Errorf("not implemented: DelEnrichedData - delEnrichedData"))
}

// UpdateEnrichedData is the resolver for the updateEnrichedData field.
func (r *mutationResolver) UpdateEnrichedData(ctx context.Context, id string, input model.UpdateEnrichedData) (*model.EnrichedData, error) {
	panic(fmt.Errorf("not implemented: UpdateEnrichedData - updateEnrichedData"))
}

// EnrichedData is the resolver for the EnrichedData field.
func (r *queryResolver) EnrichedData(ctx context.Context, page *int, age *string, gender *string, nationality *string) ([]*model.EnrichedData, error) {
	godotenv.Load(".env")
	databaseURL := os.Getenv("DATABASE_URL")
	db, err := pgx.Connect(context.Background(), databaseURL)
	if err != nil {
		return nil, err
	}
	defer db.Close(context.Background())

	query, queryArgs := generateGetQuery(*age, *gender, *nationality, *page)
	rows, err := db.Query(context.Background(), query, queryArgs...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	results := []*model.EnrichedData{}
	for rows.Next() {
		var data model.EnrichedData
		err := rows.Scan(&data.ID, &data.Name, &data.Surname, &data.Patronymic, &data.Age, &data.Gender, &data.Nationality)
		if err != nil {
			return nil, err
		}
		results = append(results, &data)
	}
	return results, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

func sqlCheckAndWriteArg(arg string, argName string, args *[]interface{}, queryBuilder *strings.Builder) {
	if arg == "" {
		return
	}
	*args = append(*args, arg)
	queryBuilder.WriteString(" AND ")
	queryBuilder.WriteString(argName)
	queryBuilder.WriteString(" = $")
	queryBuilder.WriteString(strconv.Itoa(len(*args)))
}

func sqlWriteArg(arg int, argName string, args *[]interface{}, queryBuilder *strings.Builder) {
	*args = append(*args, arg)
	queryBuilder.WriteString(" ")
	queryBuilder.WriteString(argName)
	queryBuilder.WriteString(" $")
	queryBuilder.WriteString(strconv.Itoa(len(*args)))
}

func generateGetQuery(age string, gender string, nationality string, pageInt int) (string, []interface{}) {
	limit := 10
	offset := (pageInt - 1) * limit

	queryBuilder := strings.Builder{}
	queryBuilder.WriteString("SELECT * FROM enriched_data WHERE 1=1")
	args := []interface{}{}

	sqlCheckAndWriteArg(age, "age", &args, &queryBuilder)
	sqlCheckAndWriteArg(gender, "gender", &args, &queryBuilder)
	sqlCheckAndWriteArg(nationality, "nationality", &args, &queryBuilder)
	sqlWriteArg(limit, "LIMIT", &args, &queryBuilder)
	sqlWriteArg(offset, "OFFSET", &args, &queryBuilder)

	return queryBuilder.String(), args
}
